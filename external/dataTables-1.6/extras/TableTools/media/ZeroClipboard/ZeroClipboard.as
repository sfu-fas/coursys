package {	import flash.display.Stage;	import flash.display.Sprite;	import flash.display.LoaderInfo;	import flash.display.StageScaleMode;	import flash.events.*;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.external.ExternalInterface;	import flash.system.Security;	import flash.utils.*;	import flash.system.System;	import flash.net.FileReference;	import flash.net.FileFilter; 	public class ZeroClipboard extends Sprite {				private var id:String = '';		private var button:Sprite;		private var clipText:String = 'blank';		private var fileName:String = '';		private var action:String = 'copy';				public function ZeroClipboard() {			// constructor, setup event listeners and external interfaces			stage.scaleMode = StageScaleMode.EXACT_FIT;			flash.system.Security.allowDomain("*");						// import flashvars			var flashvars:Object = LoaderInfo( this.root.loaderInfo ).parameters;			id = flashvars.id;						// invisible button covers entire stage			button = new Sprite();			button.buttonMode = true;			button.useHandCursor = true;			button.graphics.beginFill(0xCCFF00);			button.graphics.drawRect(0, 0, Math.floor(flashvars.width), Math.floor(flashvars.height));			button.alpha = 0.0;			addChild(button);			button.addEventListener(MouseEvent.CLICK, clickHandler);						button.addEventListener(MouseEvent.MOUSE_OVER, function(event:Event) {				ExternalInterface.call( 'ZeroClipboard.dispatch', id, 'mouseOver', null );			} );			button.addEventListener(MouseEvent.MOUSE_OUT, function(event:Event) {				ExternalInterface.call( 'ZeroClipboard.dispatch', id, 'mouseOut', null );			} );			button.addEventListener(MouseEvent.MOUSE_DOWN, function(event:Event) {				ExternalInterface.call( 'ZeroClipboard.dispatch', id, 'mouseDown', null );			} );			button.addEventListener(MouseEvent.MOUSE_UP, function(event:Event) {				ExternalInterface.call( 'ZeroClipboard.dispatch', id, 'mouseUp', null );			} );						// external functions			ExternalInterface.addCallback("setHandCursor", setHandCursor);			ExternalInterface.addCallback("clearText", clearText);			ExternalInterface.addCallback("setText", setText);			ExternalInterface.addCallback("setFileName", setFileName);			ExternalInterface.addCallback("setAction", setAction);						// signal to the browser that we are ready			ExternalInterface.call( 'ZeroClipboard.dispatch', id, 'load', null );		}				public function clearText() {			clipText = '';		}				public function setText(newText:String) {			clipText += newText;		}				public function setFileName(newFileName:String) {			fileName = newFileName;		}				public function setAction(newAction:String) {			action = newAction;		}				public function setHandCursor(enabled:Boolean) {			// control whether the hand cursor is shown on rollover (true)			// or the default arrow cursor (false)			button.useHandCursor = enabled;		}				private function clickHandler(event:Event):void {			if ( action == "save" ) {				var fileRef:FileReference = new FileReference();								/* If we are saving to an XLS, we must use UTF16LE */				var xlsPattern:RegExp = /\.xls$/;				if ( xlsPattern.test(fileName) ) {					fileRef.save( strToUTF16(clipText), fileName );				} else {					fileRef.save( strToUTF8(clipText), fileName );				}			} else {				/* Copy the text to the clipboard */				System.setClipboard( clipText );			}			ExternalInterface.call( 'ZeroClipboard.dispatch', id, 'complete', clipText );		}						/*		 * Function: utf8to8		 * Purpose:  Convert a string to the output utf-8		 * Returns:  ByteArray		 * Inputs:   String		 */		private function strToUTF8( str:String ):ByteArray		{			var utf8:ByteArray = new ByteArray();						/* BOM first */			utf8.writeByte( 0xEF );			utf8.writeByte( 0xBB );			utf8.writeByte( 0xBF );			utf8.writeUTFBytes( str );						return utf8;		}						/*		 * Function: strToUTF16		 * Purpose:  Convert a string to the output utf-16		 * Returns:  ByteArray		 * Inputs:   String		 * Notes:    The fact that this function is needed is a little annoying. Basically, strings in		 *   AS3 are UTF-16 (with surrogate pairs and everything), but characters which take up less		 *   than 8 bytes appear to be stored as only 8 bytes. This function effective adds the padding		 *   required, and the BOM		 */		private function strToUTF16( str:String ):ByteArray		{			var utf16:ByteArray = new ByteArray();			var iChar:uint;			var i:uint, iLen:uint = str.length;			var iSurr1:uint, iSurr2:uint, iSurrMod:uint;						/* BOM first */			utf16.writeByte( 0xFF );			utf16.writeByte( 0xFE );						while ( i < iLen )			{				iChar = str.charCodeAt(i);				trace( iChar );								if ( iChar < 0xFF )				{					/* one byte char */					utf16.writeByte( iChar );					utf16.writeByte( 0 );				}				else				{					/* two byte char */					utf16.writeByte( iChar & 0x00FF );					utf16.writeByte( iChar >> 8 );				}								i++;			}						return utf16;		}	}}